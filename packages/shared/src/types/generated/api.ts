/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
    "/v1/search": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Search legal documents
         * @description Search across legal document datastores (precedent, infobank, workspace).
         *     MVP supports only `precedent` scope.
         */
        post: operations["search"];
        delete?: never;
        /**
         * CORS preflight for search endpoint
         * @description Handles CORS preflight (OPTIONS) requests for /v1/search.
         *
         *     **Note:** This OPTIONS definition serves as a reference contract for CORS preflight across
         *     all API endpoints. While not every endpoint has an explicit OPTIONS definition in this spec
         *     (to avoid verbosity), the middleware/gateway layer responds to OPTIONS for all paths with
         *     the same headers shown here.
         */
        options: operations["searchPreflight"];
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/chat": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Ask a question and get an answer with citations
         * @description Submit a question to get an AI-generated answer with citations from legal documents.
         *     For multi-turn conversations, include the full message history in the `messages` array.
         */
        post: operations["chat"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/chat/stream": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Streaming chat with citations (POST-MVP)
         * @description **STATUS: POST-MVP - NOT IMPLEMENTED**
         *
         *     Server-Sent Events (SSE) streaming version of /v1/chat. Controlled by `STREAMING_ENABLED` feature flag.
         *
         *     When implemented, will stream answer chunks as SSE events. Frontend must use `fetch()` + `ReadableStream`
         *     (not `EventSource` which doesn't support Authorization header).
         *
         *     MVP uses synchronous /v1/chat endpoint instead. This endpoint specification will be completed when
         *     streaming implementation begins.
         */
        post: operations["chatStream"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/feedback": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Submit feedback on an answer
         * @description Submit thumbs up/down feedback with optional comment on a chat answer.
         */
        post: operations["submitFeedback"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/me": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get current user profile
         * @description Returns current user information including Google Workspace connection status.
         */
        get: operations["getMe"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/flags": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get feature flags
         * @description Returns feature flags for the current user/environment.
         */
        get: operations["getFlags"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/health": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Health check
         * @description Returns backend health status. No authentication required.
         */
        get: operations["getHealth"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/oauth/google/connect": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Initiate Google Workspace OAuth flow
         * @description Initiates OAuth 2.0 authorization code flow with PKCE for Google Workspace integration.
         *     Returns a 302 redirect to Google's OAuth consent screen.
         *
         *     **Implementation Note:** This endpoint is public (no auth required) because SPAs cannot send
         *     Authorization headers or custom headers (X-Session-Id) during a 302 redirect. The frontend
         *     initiates this flow via `window.location.href` or an `<a>` tag, which cannot include headers.
         *
         *     **Security:** Issues cryptographically strong state token (UUID v4 + entropy), stores state with
         *     session binding (Kinde user ID from cookie/session, PKCE verifier hash, redirect URL, TTL=10min).
         *     The state token provides CSRF protection and session binding. Enforces redirect URL allowlist to
         *     prevent open redirect attacks (Issue #3).
         *
         *     **Session Binding:** Backend extracts Kinde user ID from session cookie (not Authorization header)
         *     to bind the state token to the authenticated user.
         */
        get: operations["oauthGoogleConnect"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/oauth/google/callback": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Handle OAuth callback from Google
         * @description OAuth 2.0 callback endpoint. Google redirects here after user approves/denies consent.
         *
         *     **Security:** Validates state token (exists, not expired, not reused, matches current session),
         *     validates PKCE code_verifier against stored challenge (Issue #2), verifies Google account email
         *     matches Kinde user email to prevent token misbinding (Issue #4), exchanges authorization code for
         *     tokens with Google, encrypts tokens with Cloud KMS before storing in Firestore (Issue #5),
         *     deletes state token (one-time use).
         *
         *     **Note:** This is a public callback endpoint (no Kinde auth). X-Session-Id and X-Request-Id are
         *     not required since Google controls the redirect. Session binding is handled via the state token.
         */
        get: operations["oauthGoogleCallback"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/me/workspace": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        /**
         * Disconnect Google Workspace
         * @description Revokes Google Workspace OAuth tokens and deletes stored credentials.
         *
         *     **Security:** Revokes refresh token via Google OAuth API, deletes UserTokens Firestore document,
         *     logs revocation event for audit trail.
         */
        delete: operations["disconnectWorkspace"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
}
export type webhooks = Record<string, never>;
export interface components {
    schemas: {
        /**
         * @description Search scope. MVP supports only `precedent`.
         * @enum {string}
         */
        Scope: "precedent" | "infobank" | "both" | "workspace";
        /**
         * @description Document source datastore.
         * @enum {string}
         */
        Source: "precedent" | "infobank" | "workspace";
        /** @enum {string} */
        DocumentType: "judgment" | "decree" | "circular" | "internal" | "email" | "doc";
        /** @enum {string} */
        Jurisdiction: "civil" | "criminal" | "administrative" | "labor";
        /** @enum {string} */
        Language: "vi" | "en";
        /** @enum {string} */
        Confidentiality: "internal" | "public";
        /**
         * @description Canonical error codes. See SRS Section 6.3.
         * @enum {string}
         */
        ErrorCode: "AUTH_INVALID_TOKEN" | "AUTH_DOMAIN_REJECTED" | "AUTH_GOOGLE_DISCONNECTED" | "FORBIDDEN" | "NOT_FOUND" | "VALIDATION_ERROR" | "INVALID_REQUEST" | "QUERY_TOO_LONG" | "RATE_LIMITED" | "SEARCH_TIMEOUT" | "REQUEST_TIMEOUT" | "UPSTREAM_ERROR" | "SERVICE_UNAVAILABLE" | "DATASTORE_UNAVAILABLE" | "INTERNAL_ERROR";
        SearchRequest: {
            /** @description Search query text */
            query: string;
            scope: components["schemas"]["Scope"];
            /**
             * @description Number of results per page
             * @default 10
             */
            pageSize: number;
            /** @description Opaque pagination cursor from previous response */
            cursor?: string | null;
        };
        ResultMetadata: {
            documentType?: components["schemas"]["DocumentType"];
            /**
             * Format: date
             * @description Document date (YYYY-MM-DD)
             */
            date?: string;
            /** @description Court name (for precedent documents) */
            court?: string;
            /** @description Case identifier */
            caseNumber?: string;
            jurisdiction?: components["schemas"]["Jurisdiction"];
            /** @description Party names */
            parties?: string[];
            /** @description Judge name */
            judge?: string;
            /**
             * Format: date-time
             * @description Last modification timestamp (ISO-8601)
             */
            lastModified?: string;
            confidentiality?: components["schemas"]["Confidentiality"];
            language?: components["schemas"]["Language"];
        };
        SearchResult: {
            /** @description Document title */
            title: string;
            /** @description Relevant excerpt */
            snippet: string;
            /**
             * Format: uri
             * @description Document URL
             */
            url: string;
            source: components["schemas"]["Source"];
            metadata: components["schemas"]["ResultMetadata"];
        };
        DatastoreStatus: {
            /** @enum {string} */
            status: "success" | "error";
            /** @description Total matches in datastore (may be approximate) */
            resultCount: number;
            /** @description Error message if status is error */
            error?: string | null;
        };
        AuthStatus: {
            /** @description True if user should connect Google Workspace */
            needsGoogleConnect: boolean;
            /**
             * Format: uri
             * @description OAuth URL to connect Google Workspace
             */
            connectUrl?: string | null;
        };
        SearchResponse: {
            /**
             * Format: uuid
             * @description Unique request identifier for tracing
             */
            requestId: string;
            /** @description Original query */
            query: string;
            scope: components["schemas"]["Scope"];
            /**
             * @description Overall status. "partial" means some datastores failed.
             * @enum {string}
             */
            status: "success" | "partial";
            /** @description AI-generated answer summary (optional) */
            answer?: string | null;
            results: components["schemas"]["SearchResult"][];
            /** @description Cursor for next page (null if no more results) */
            nextCursor?: string | null;
            datastoreStatus: {
                precedent: components["schemas"]["DatastoreStatus"];
                infobank: components["schemas"]["DatastoreStatus"];
                workspace: components["schemas"]["DatastoreStatus"];
            };
            /** @description Warning messages for partial failures */
            warnings?: string[];
            auth: components["schemas"]["AuthStatus"];
            /**
             * @description Optional debugging/diagnostic metadata. MAY be omitted. Contents MAY change without version bump.
             *     Clients SHOULD use passthrough parsing (e.g., Zod `.passthrough()`).
             *
             *     Example properties:
             *     - durationMs: Backend processing time in milliseconds
             *     - totalResults: Total number of results found (before pagination)
             *     - displayedResults: Number of results included in this response
             *     - source: Data source identifier (e.g., "Discovery Engine")
             *     - isDemoMode: Whether demo mode is active
             * @example {
             *       "durationMs": 1500,
             *       "totalResults": 69,
             *       "displayedResults": 5,
             *       "source": "Discovery Engine",
             *       "isDemoMode": false
             *     }
             */
            _meta?: {
                [key: string]: unknown;
            };
        };
        ChatMessage: {
            /**
             * @description Message sender role
             * @enum {string}
             */
            role: "user" | "assistant";
            /** @description Message content */
            content: string;
        };
        ChatRequest: {
            /** @description Existing conversation ID (null for new conversation) */
            conversationId?: string | null;
            /** @description Current user message */
            message: string;
            /**
             * @description Full conversation history for multi-turn context.
             *     Frontend sends all previous messages. Backend uses this for context.
             *     If omitted, treated as new conversation.
             */
            messages?: components["schemas"]["ChatMessage"][];
            scope: components["schemas"]["Scope"];
            /**
             * @description If true, regenerate the last assistant response
             * @default false
             */
            regenerate: boolean;
        };
        Citation: {
            /** @description Document title */
            title: string;
            /**
             * Format: uri
             * @description Document URL
             */
            url: string;
            /** @description Relevant excerpt */
            snippet?: string | null;
            source: components["schemas"]["Source"];
        };
        ChatResponse: {
            /**
             * Format: uuid
             * @description Unique request identifier for tracing
             */
            requestId: string;
            /** @description Conversation identifier */
            conversationId: string;
            /** @description Unique message ID (use for feedback submission) */
            messageId: string;
            /** @description AI-generated answer */
            answer: string;
            citations: components["schemas"]["Citation"][];
            auth: components["schemas"]["AuthStatus"];
            /**
             * @description True if conversation history was truncated due to context window limits.
             *     Frontend should display a warning to user.
             * @default false
             */
            contextLimitWarning: boolean;
            /**
             * @description Optional debugging/diagnostic metadata. MAY be omitted. Contents MAY change without version bump.
             *     Clients SHOULD use passthrough parsing (e.g., Zod `.passthrough()`).
             *
             *     Example properties:
             *     - durationMs: Backend processing time in milliseconds
             *     - source: Data source identifier
             *     - isDemoMode: Whether demo mode is active
             * @example {
             *       "durationMs": 850,
             *       "source": "Chat API",
             *       "isDemoMode": false
             *     }
             */
            _meta?: {
                [key: string]: unknown;
            };
        };
        FeedbackRequest: {
            /** @description Message ID from ChatResponse */
            messageId: string;
            /** @description Conversation ID */
            conversationId: string;
            /**
             * @description Feedback type (thumbs up/down)
             * @enum {string}
             */
            type: "up" | "down";
            /** @description Optional comment */
            comment?: string | null;
        };
        FeedbackResponse: {
            /** Format: uuid */
            requestId: string;
            /** @enum {string} */
            status: "received";
        };
        WorkspaceStatus: {
            /** @description Whether Google Workspace is connected */
            connected: boolean;
            /**
             * Format: email
             * @description Connected Google account email
             */
            connectedEmail?: string | null;
            /** @description Granted scope keys (e.g., "cloud_search") */
            scopes: string[];
            /**
             * Format: uri
             * @description URL to connect Google Workspace
             */
            connectUrl?: string | null;
        };
        UserProfile: {
            /**
             * Format: uuid
             * @description Unique request identifier for tracing
             */
            requestId: string;
            /**
             * Format: email
             * @description User email (must be @vnlaw.com.vn)
             */
            email: string;
            /** @description User display name */
            name?: string | null;
            /**
             * Format: uri
             * @description Profile picture URL
             */
            picture?: string | null;
            workspace: components["schemas"]["WorkspaceStatus"];
        };
        FeatureFlags: {
            /** @default false */
            WORKSPACE_SEARCH_ENABLED: boolean;
            /** @default false */
            CHAT_HISTORY_ENABLED: boolean;
            /** @default false */
            STREAMING_ENABLED: boolean;
            /** @default true */
            FEEDBACK_ENABLED: boolean;
            /** @default true */
            EXPORT_ENABLED: boolean;
            /** @default false */
            INFOBANK_SEARCH_ENABLED: boolean;
        };
        FlagsResponse: {
            /**
             * Format: uuid
             * @description Unique request identifier for tracing
             */
            requestId: string;
            flags: components["schemas"]["FeatureFlags"];
        };
        DependencyStatus: {
            /** @enum {string} */
            status: "up" | "down";
            /** @description Latency in milliseconds */
            latencyMs?: number;
        };
        HealthResponse: {
            /**
             * Format: uuid
             * @description Unique request identifier for tracing
             */
            requestId: string;
            /** @enum {string} */
            status: "healthy" | "degraded" | "unhealthy";
            /** @description API version */
            version: string;
            /** Format: date-time */
            timestamp: string;
            dependencies: {
                [key: string]: components["schemas"]["DependencyStatus"];
            };
        };
        BaseError: {
            /** @description Error code (discriminator for error type) */
            code: string;
            /** @description Human-readable error message */
            message: string;
            /**
             * Format: uuid
             * @description Request ID for support reference
             */
            requestId: string;
            /** @description Whether the request can be retried */
            retryable: boolean;
            /** @description Seconds to wait before retrying (if retryable) */
            retryAfterSeconds?: number | null;
        };
        AuthGoogleDisconnectedError: components["schemas"]["BaseError"] & {
            /**
             * @description Error code (fixed for this error type)
             * @enum {string}
             */
            code?: "AUTH_GOOGLE_DISCONNECTED";
            details: {
                /**
                 * Format: uri
                 * @description OAuth initiation URL for reconnecting Google Workspace
                 * @example https://api.vnlaw.app/v1/oauth/google/connect?redirect=/workspace
                 */
                connectUrl: string;
                /**
                 * @description Required OAuth scopes for reconnection
                 * @example [
                 *       "cloud_search"
                 *     ]
                 */
                requiredScopes?: "cloud_search"[];
            };
        } & {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            code: "AUTH_GOOGLE_DISCONNECTED";
        };
        ValidationError: components["schemas"]["BaseError"] & {
            /**
             * @description Error code (validation-related codes)
             * @enum {string}
             */
            code?: "VALIDATION_ERROR" | "INVALID_REQUEST" | "QUERY_TOO_LONG";
            /**
             * @description Field-level validation errors (fieldName -> error messages)
             * @example {
             *       "query": [
             *         "Query must be between 1 and 500 characters"
             *       ],
             *       "scope": [
             *         "Invalid scope value"
             *       ]
             *     }
             */
            details?: {
                [key: string]: string[];
            };
        } & {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            code: "VALIDATION_ERROR" | "INVALID_REQUEST" | "QUERY_TOO_LONG";
        };
        GenericError: components["schemas"]["BaseError"] & {
            /**
             * @description Error code (generic error codes)
             * @enum {string}
             */
            code?: "AUTH_INVALID_TOKEN" | "AUTH_DOMAIN_REJECTED" | "FORBIDDEN" | "NOT_FOUND" | "RATE_LIMITED" | "SEARCH_TIMEOUT" | "REQUEST_TIMEOUT" | "UPSTREAM_ERROR" | "SERVICE_UNAVAILABLE" | "DATASTORE_UNAVAILABLE" | "INTERNAL_ERROR";
            /** @description Additional error context (structure varies by error code) */
            details?: {
                [key: string]: unknown;
            };
        } & {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            code: "AUTH_INVALID_TOKEN" | "AUTH_DOMAIN_REJECTED" | "FORBIDDEN" | "NOT_FOUND" | "RATE_LIMITED" | "SEARCH_TIMEOUT" | "REQUEST_TIMEOUT" | "UPSTREAM_ERROR" | "SERVICE_UNAVAILABLE" | "DATASTORE_UNAVAILABLE" | "INTERNAL_ERROR";
        };
        APIError: components["schemas"]["AuthGoogleDisconnectedError"] | components["schemas"]["ValidationError"] | components["schemas"]["GenericError"];
        ErrorResponse: {
            error: components["schemas"]["APIError"];
        };
    };
    responses: never;
    parameters: {
        /**
         * @description Client-generated session ID (UUID v4) persisted per browser tab.
         *     Generated via `crypto.randomUUID()` on first use, stored in sessionStorage.
         *     Required for all authenticated endpoints. Unique per tab instance.
         */
        XSessionId: string;
        /** @description Optional client-generated request ID (UUID v4). If omitted, backend generates its own requestId. */
        XRequestId: string;
    };
    requestBodies: never;
    headers: {
        /** @description Maximum requests allowed in the current window. */
        "X-RateLimit-Limit": number;
        /** @description Remaining requests in the current window. */
        "X-RateLimit-Remaining": number;
        /** @description Unix epoch seconds when the current window resets. */
        "X-RateLimit-Reset": number;
        /** @description Seconds to wait before retrying the request. */
        "Retry-After": number;
    };
    pathItems: never;
}
export type $defs = Record<string, never>;
export interface operations {
    search: {
        parameters: {
            query?: never;
            header: {
                /**
                 * @description Client-generated session ID (UUID v4) persisted per browser tab.
                 *     Generated via `crypto.randomUUID()` on first use, stored in sessionStorage.
                 *     Required for all authenticated endpoints. Unique per tab instance.
                 */
                "X-Session-Id": components["parameters"]["XSessionId"];
                /** @description Optional client-generated request ID (UUID v4). If omitted, backend generates its own requestId. */
                "X-Request-Id"?: components["parameters"]["XRequestId"];
            };
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["SearchRequest"];
            };
        };
        responses: {
            /** @description Search completed successfully */
            200: {
                headers: {
                    "X-RateLimit-Limit": components["headers"]["X-RateLimit-Limit"];
                    "X-RateLimit-Remaining": components["headers"]["X-RateLimit-Remaining"];
                    "X-RateLimit-Reset": components["headers"]["X-RateLimit-Reset"];
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SearchResponse"];
                };
            };
            /** @description Partial success - some datastores failed */
            207: {
                headers: {
                    "X-RateLimit-Limit": components["headers"]["X-RateLimit-Limit"];
                    "X-RateLimit-Remaining": components["headers"]["X-RateLimit-Remaining"];
                    "X-RateLimit-Reset": components["headers"]["X-RateLimit-Reset"];
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SearchResponse"];
                };
            };
            /** @description Invalid request */
            400: {
                headers: {
                    "X-RateLimit-Limit": components["headers"]["X-RateLimit-Limit"];
                    "X-RateLimit-Remaining": components["headers"]["X-RateLimit-Remaining"];
                    "X-RateLimit-Reset": components["headers"]["X-RateLimit-Reset"];
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Authentication required */
            401: {
                headers: {
                    "X-RateLimit-Limit": components["headers"]["X-RateLimit-Limit"];
                    "X-RateLimit-Remaining": components["headers"]["X-RateLimit-Remaining"];
                    "X-RateLimit-Reset": components["headers"]["X-RateLimit-Reset"];
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Access denied */
            403: {
                headers: {
                    "X-RateLimit-Limit": components["headers"]["X-RateLimit-Limit"];
                    "X-RateLimit-Remaining": components["headers"]["X-RateLimit-Remaining"];
                    "X-RateLimit-Reset": components["headers"]["X-RateLimit-Reset"];
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Rate limited */
            429: {
                headers: {
                    "X-RateLimit-Limit": components["headers"]["X-RateLimit-Limit"];
                    "X-RateLimit-Remaining": components["headers"]["X-RateLimit-Remaining"];
                    "X-RateLimit-Reset": components["headers"]["X-RateLimit-Reset"];
                    "Retry-After": components["headers"]["Retry-After"];
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Server error */
            500: {
                headers: {
                    "X-RateLimit-Limit": components["headers"]["X-RateLimit-Limit"];
                    "X-RateLimit-Remaining": components["headers"]["X-RateLimit-Remaining"];
                    "X-RateLimit-Reset": components["headers"]["X-RateLimit-Reset"];
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Upstream error */
            502: {
                headers: {
                    "X-RateLimit-Limit": components["headers"]["X-RateLimit-Limit"];
                    "X-RateLimit-Remaining": components["headers"]["X-RateLimit-Remaining"];
                    "X-RateLimit-Reset": components["headers"]["X-RateLimit-Reset"];
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Service unavailable */
            503: {
                headers: {
                    "X-RateLimit-Limit": components["headers"]["X-RateLimit-Limit"];
                    "X-RateLimit-Remaining": components["headers"]["X-RateLimit-Remaining"];
                    "X-RateLimit-Reset": components["headers"]["X-RateLimit-Reset"];
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Request timeout */
            504: {
                headers: {
                    "X-RateLimit-Limit": components["headers"]["X-RateLimit-Limit"];
                    "X-RateLimit-Remaining": components["headers"]["X-RateLimit-Remaining"];
                    "X-RateLimit-Reset": components["headers"]["X-RateLimit-Reset"];
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    searchPreflight: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Preflight successful */
            204: {
                headers: {
                    /** @description Validated origin (echoed from request, NOT wildcard) */
                    "Access-Control-Allow-Origin"?: string;
                    /** @description Allowed HTTP methods for this endpoint */
                    "Access-Control-Allow-Methods"?: string;
                    /** @description Allowed request headers (required for custom headers) */
                    "Access-Control-Allow-Headers"?: string;
                    /** @description Preflight cache duration in seconds (24 hours) */
                    "Access-Control-Max-Age"?: number;
                    /** @description Required when origin is dynamic (for cache correctness) */
                    Vary?: string;
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    chat: {
        parameters: {
            query?: never;
            header: {
                /**
                 * @description Client-generated session ID (UUID v4) persisted per browser tab.
                 *     Generated via `crypto.randomUUID()` on first use, stored in sessionStorage.
                 *     Required for all authenticated endpoints. Unique per tab instance.
                 */
                "X-Session-Id": components["parameters"]["XSessionId"];
                /** @description Optional client-generated request ID (UUID v4). If omitted, backend generates its own requestId. */
                "X-Request-Id"?: components["parameters"]["XRequestId"];
            };
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["ChatRequest"];
            };
        };
        responses: {
            /** @description Answer generated successfully */
            200: {
                headers: {
                    "X-RateLimit-Limit": components["headers"]["X-RateLimit-Limit"];
                    "X-RateLimit-Remaining": components["headers"]["X-RateLimit-Remaining"];
                    "X-RateLimit-Reset": components["headers"]["X-RateLimit-Reset"];
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ChatResponse"];
                };
            };
            /** @description Invalid request */
            400: {
                headers: {
                    "X-RateLimit-Limit": components["headers"]["X-RateLimit-Limit"];
                    "X-RateLimit-Remaining": components["headers"]["X-RateLimit-Remaining"];
                    "X-RateLimit-Reset": components["headers"]["X-RateLimit-Reset"];
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Authentication required */
            401: {
                headers: {
                    "X-RateLimit-Limit": components["headers"]["X-RateLimit-Limit"];
                    "X-RateLimit-Remaining": components["headers"]["X-RateLimit-Remaining"];
                    "X-RateLimit-Reset": components["headers"]["X-RateLimit-Reset"];
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Access denied */
            403: {
                headers: {
                    "X-RateLimit-Limit": components["headers"]["X-RateLimit-Limit"];
                    "X-RateLimit-Remaining": components["headers"]["X-RateLimit-Remaining"];
                    "X-RateLimit-Reset": components["headers"]["X-RateLimit-Reset"];
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Rate limited */
            429: {
                headers: {
                    "X-RateLimit-Limit": components["headers"]["X-RateLimit-Limit"];
                    "X-RateLimit-Remaining": components["headers"]["X-RateLimit-Remaining"];
                    "X-RateLimit-Reset": components["headers"]["X-RateLimit-Reset"];
                    "Retry-After": components["headers"]["Retry-After"];
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Server error */
            500: {
                headers: {
                    "X-RateLimit-Limit": components["headers"]["X-RateLimit-Limit"];
                    "X-RateLimit-Remaining": components["headers"]["X-RateLimit-Remaining"];
                    "X-RateLimit-Reset": components["headers"]["X-RateLimit-Reset"];
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Upstream error */
            502: {
                headers: {
                    "X-RateLimit-Limit": components["headers"]["X-RateLimit-Limit"];
                    "X-RateLimit-Remaining": components["headers"]["X-RateLimit-Remaining"];
                    "X-RateLimit-Reset": components["headers"]["X-RateLimit-Reset"];
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Service unavailable */
            503: {
                headers: {
                    "X-RateLimit-Limit": components["headers"]["X-RateLimit-Limit"];
                    "X-RateLimit-Remaining": components["headers"]["X-RateLimit-Remaining"];
                    "X-RateLimit-Reset": components["headers"]["X-RateLimit-Reset"];
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Request timeout */
            504: {
                headers: {
                    "X-RateLimit-Limit": components["headers"]["X-RateLimit-Limit"];
                    "X-RateLimit-Remaining": components["headers"]["X-RateLimit-Remaining"];
                    "X-RateLimit-Reset": components["headers"]["X-RateLimit-Reset"];
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    chatStream: {
        parameters: {
            query?: never;
            header: {
                /**
                 * @description Client-generated session ID (UUID v4) persisted per browser tab.
                 *     Generated via `crypto.randomUUID()` on first use, stored in sessionStorage.
                 *     Required for all authenticated endpoints. Unique per tab instance.
                 */
                "X-Session-Id": components["parameters"]["XSessionId"];
                /** @description Optional client-generated request ID (UUID v4). If omitted, backend generates its own requestId. */
                "X-Request-Id"?: components["parameters"]["XRequestId"];
            };
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["ChatRequest"];
            };
        };
        responses: {
            /** @description SSE stream of chat response chunks (POST-MVP - not implemented) */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "text/event-stream": string;
                };
            };
            /** @description Invalid request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Authentication required */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Access denied or STREAMING_ENABLED=false */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Rate limited */
            429: {
                headers: {
                    "X-RateLimit-Limit": components["headers"]["X-RateLimit-Limit"];
                    "X-RateLimit-Remaining": components["headers"]["X-RateLimit-Remaining"];
                    "X-RateLimit-Reset": components["headers"]["X-RateLimit-Reset"];
                    "Retry-After": components["headers"]["Retry-After"];
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    submitFeedback: {
        parameters: {
            query?: never;
            header: {
                /**
                 * @description Client-generated session ID (UUID v4) persisted per browser tab.
                 *     Generated via `crypto.randomUUID()` on first use, stored in sessionStorage.
                 *     Required for all authenticated endpoints. Unique per tab instance.
                 */
                "X-Session-Id": components["parameters"]["XSessionId"];
                /** @description Optional client-generated request ID (UUID v4). If omitted, backend generates its own requestId. */
                "X-Request-Id"?: components["parameters"]["XRequestId"];
            };
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["FeedbackRequest"];
            };
        };
        responses: {
            /** @description Feedback received */
            200: {
                headers: {
                    "X-RateLimit-Limit": components["headers"]["X-RateLimit-Limit"];
                    "X-RateLimit-Remaining": components["headers"]["X-RateLimit-Remaining"];
                    "X-RateLimit-Reset": components["headers"]["X-RateLimit-Reset"];
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["FeedbackResponse"];
                };
            };
            /** @description Invalid request */
            400: {
                headers: {
                    "X-RateLimit-Limit": components["headers"]["X-RateLimit-Limit"];
                    "X-RateLimit-Remaining": components["headers"]["X-RateLimit-Remaining"];
                    "X-RateLimit-Reset": components["headers"]["X-RateLimit-Reset"];
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Authentication required */
            401: {
                headers: {
                    "X-RateLimit-Limit": components["headers"]["X-RateLimit-Limit"];
                    "X-RateLimit-Remaining": components["headers"]["X-RateLimit-Remaining"];
                    "X-RateLimit-Reset": components["headers"]["X-RateLimit-Reset"];
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Access denied */
            403: {
                headers: {
                    "X-RateLimit-Limit": components["headers"]["X-RateLimit-Limit"];
                    "X-RateLimit-Remaining": components["headers"]["X-RateLimit-Remaining"];
                    "X-RateLimit-Reset": components["headers"]["X-RateLimit-Reset"];
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Rate limited */
            429: {
                headers: {
                    "X-RateLimit-Limit": components["headers"]["X-RateLimit-Limit"];
                    "X-RateLimit-Remaining": components["headers"]["X-RateLimit-Remaining"];
                    "X-RateLimit-Reset": components["headers"]["X-RateLimit-Reset"];
                    "Retry-After": components["headers"]["Retry-After"];
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Server error */
            500: {
                headers: {
                    "X-RateLimit-Limit": components["headers"]["X-RateLimit-Limit"];
                    "X-RateLimit-Remaining": components["headers"]["X-RateLimit-Remaining"];
                    "X-RateLimit-Reset": components["headers"]["X-RateLimit-Reset"];
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Upstream error */
            502: {
                headers: {
                    "X-RateLimit-Limit": components["headers"]["X-RateLimit-Limit"];
                    "X-RateLimit-Remaining": components["headers"]["X-RateLimit-Remaining"];
                    "X-RateLimit-Reset": components["headers"]["X-RateLimit-Reset"];
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Service unavailable */
            503: {
                headers: {
                    "X-RateLimit-Limit": components["headers"]["X-RateLimit-Limit"];
                    "X-RateLimit-Remaining": components["headers"]["X-RateLimit-Remaining"];
                    "X-RateLimit-Reset": components["headers"]["X-RateLimit-Reset"];
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    getMe: {
        parameters: {
            query?: never;
            header: {
                /**
                 * @description Client-generated session ID (UUID v4) persisted per browser tab.
                 *     Generated via `crypto.randomUUID()` on first use, stored in sessionStorage.
                 *     Required for all authenticated endpoints. Unique per tab instance.
                 */
                "X-Session-Id": components["parameters"]["XSessionId"];
                /** @description Optional client-generated request ID (UUID v4). If omitted, backend generates its own requestId. */
                "X-Request-Id"?: components["parameters"]["XRequestId"];
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description User profile retrieved */
            200: {
                headers: {
                    "X-RateLimit-Limit": components["headers"]["X-RateLimit-Limit"];
                    "X-RateLimit-Remaining": components["headers"]["X-RateLimit-Remaining"];
                    "X-RateLimit-Reset": components["headers"]["X-RateLimit-Reset"];
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["UserProfile"];
                };
            };
            /** @description Authentication required */
            401: {
                headers: {
                    "X-RateLimit-Limit": components["headers"]["X-RateLimit-Limit"];
                    "X-RateLimit-Remaining": components["headers"]["X-RateLimit-Remaining"];
                    "X-RateLimit-Reset": components["headers"]["X-RateLimit-Reset"];
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Access denied */
            403: {
                headers: {
                    "X-RateLimit-Limit": components["headers"]["X-RateLimit-Limit"];
                    "X-RateLimit-Remaining": components["headers"]["X-RateLimit-Remaining"];
                    "X-RateLimit-Reset": components["headers"]["X-RateLimit-Reset"];
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Rate limited */
            429: {
                headers: {
                    "X-RateLimit-Limit": components["headers"]["X-RateLimit-Limit"];
                    "X-RateLimit-Remaining": components["headers"]["X-RateLimit-Remaining"];
                    "X-RateLimit-Reset": components["headers"]["X-RateLimit-Reset"];
                    "Retry-After": components["headers"]["Retry-After"];
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Server error */
            500: {
                headers: {
                    "X-RateLimit-Limit": components["headers"]["X-RateLimit-Limit"];
                    "X-RateLimit-Remaining": components["headers"]["X-RateLimit-Remaining"];
                    "X-RateLimit-Reset": components["headers"]["X-RateLimit-Reset"];
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Upstream error */
            502: {
                headers: {
                    "X-RateLimit-Limit": components["headers"]["X-RateLimit-Limit"];
                    "X-RateLimit-Remaining": components["headers"]["X-RateLimit-Remaining"];
                    "X-RateLimit-Reset": components["headers"]["X-RateLimit-Reset"];
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Service unavailable */
            503: {
                headers: {
                    "X-RateLimit-Limit": components["headers"]["X-RateLimit-Limit"];
                    "X-RateLimit-Remaining": components["headers"]["X-RateLimit-Remaining"];
                    "X-RateLimit-Reset": components["headers"]["X-RateLimit-Reset"];
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    getFlags: {
        parameters: {
            query?: never;
            header: {
                /**
                 * @description Client-generated session ID (UUID v4) persisted per browser tab.
                 *     Generated via `crypto.randomUUID()` on first use, stored in sessionStorage.
                 *     Required for all authenticated endpoints. Unique per tab instance.
                 */
                "X-Session-Id": components["parameters"]["XSessionId"];
                /** @description Optional client-generated request ID (UUID v4). If omitted, backend generates its own requestId. */
                "X-Request-Id"?: components["parameters"]["XRequestId"];
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Feature flags retrieved */
            200: {
                headers: {
                    "X-RateLimit-Limit": components["headers"]["X-RateLimit-Limit"];
                    "X-RateLimit-Remaining": components["headers"]["X-RateLimit-Remaining"];
                    "X-RateLimit-Reset": components["headers"]["X-RateLimit-Reset"];
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["FlagsResponse"];
                };
            };
            /** @description Authentication required */
            401: {
                headers: {
                    "X-RateLimit-Limit": components["headers"]["X-RateLimit-Limit"];
                    "X-RateLimit-Remaining": components["headers"]["X-RateLimit-Remaining"];
                    "X-RateLimit-Reset": components["headers"]["X-RateLimit-Reset"];
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Access denied */
            403: {
                headers: {
                    "X-RateLimit-Limit": components["headers"]["X-RateLimit-Limit"];
                    "X-RateLimit-Remaining": components["headers"]["X-RateLimit-Remaining"];
                    "X-RateLimit-Reset": components["headers"]["X-RateLimit-Reset"];
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Rate limited */
            429: {
                headers: {
                    "X-RateLimit-Limit": components["headers"]["X-RateLimit-Limit"];
                    "X-RateLimit-Remaining": components["headers"]["X-RateLimit-Remaining"];
                    "X-RateLimit-Reset": components["headers"]["X-RateLimit-Reset"];
                    "Retry-After": components["headers"]["Retry-After"];
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Server error */
            500: {
                headers: {
                    "X-RateLimit-Limit": components["headers"]["X-RateLimit-Limit"];
                    "X-RateLimit-Remaining": components["headers"]["X-RateLimit-Remaining"];
                    "X-RateLimit-Reset": components["headers"]["X-RateLimit-Reset"];
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Upstream error */
            502: {
                headers: {
                    "X-RateLimit-Limit": components["headers"]["X-RateLimit-Limit"];
                    "X-RateLimit-Remaining": components["headers"]["X-RateLimit-Remaining"];
                    "X-RateLimit-Reset": components["headers"]["X-RateLimit-Reset"];
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Service unavailable */
            503: {
                headers: {
                    "X-RateLimit-Limit": components["headers"]["X-RateLimit-Limit"];
                    "X-RateLimit-Remaining": components["headers"]["X-RateLimit-Remaining"];
                    "X-RateLimit-Reset": components["headers"]["X-RateLimit-Reset"];
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    getHealth: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Health status */
            200: {
                headers: {
                    "X-RateLimit-Limit": components["headers"]["X-RateLimit-Limit"];
                    "X-RateLimit-Remaining": components["headers"]["X-RateLimit-Remaining"];
                    "X-RateLimit-Reset": components["headers"]["X-RateLimit-Reset"];
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HealthResponse"];
                };
            };
        };
    };
    oauthGoogleConnect: {
        parameters: {
            query: {
                /**
                 * @description Return URL after OAuth completion. Must match production allowlist:
                 *     - https://vnlaw.app/workspace
                 *     - https://staging.vnlaw.app/workspace
                 * @example https://vnlaw.app/workspace
                 */
                redirect: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Redirect to Google OAuth consent screen */
            302: {
                headers: {
                    /**
                     * @description Google OAuth authorization URL with params:
                     *     - client_id: Google OAuth client ID
                     *     - redirect_uri: Callback URL (this API's /v1/oauth/google/callback)
                     *     - state: Cryptographic state token (UUID v4)
                     *     - scope: https://www.googleapis.com/auth/cloud_search.query
                     *     - code_challenge: PKCE challenge (base64url-encoded SHA256 hash)
                     *     - code_challenge_method: S256
                     *     - access_type: offline (to get refresh token)
                     *     - prompt: consent
                     * @example https://accounts.google.com/o/oauth2/v2/auth?client_id=...&redirect_uri=...&state=...&scope=...&code_challenge=...&code_challenge_method=S256&access_type=offline&prompt=consent
                     */
                    Location?: string;
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Invalid redirect URL (not in allowlist) */
            400: {
                headers: {
                    "X-RateLimit-Limit": components["headers"]["X-RateLimit-Limit"];
                    "X-RateLimit-Remaining": components["headers"]["X-RateLimit-Remaining"];
                    "X-RateLimit-Reset": components["headers"]["X-RateLimit-Reset"];
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Authentication required (invalid/expired Kinde token) */
            401: {
                headers: {
                    "X-RateLimit-Limit": components["headers"]["X-RateLimit-Limit"];
                    "X-RateLimit-Remaining": components["headers"]["X-RateLimit-Remaining"];
                    "X-RateLimit-Reset": components["headers"]["X-RateLimit-Reset"];
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description User not authorized for Workspace feature */
            403: {
                headers: {
                    "X-RateLimit-Limit": components["headers"]["X-RateLimit-Limit"];
                    "X-RateLimit-Remaining": components["headers"]["X-RateLimit-Remaining"];
                    "X-RateLimit-Reset": components["headers"]["X-RateLimit-Reset"];
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Rate limited */
            429: {
                headers: {
                    "X-RateLimit-Limit": components["headers"]["X-RateLimit-Limit"];
                    "X-RateLimit-Remaining": components["headers"]["X-RateLimit-Remaining"];
                    "X-RateLimit-Reset": components["headers"]["X-RateLimit-Reset"];
                    "Retry-After": components["headers"]["Retry-After"];
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Server error */
            500: {
                headers: {
                    "X-RateLimit-Limit": components["headers"]["X-RateLimit-Limit"];
                    "X-RateLimit-Remaining": components["headers"]["X-RateLimit-Remaining"];
                    "X-RateLimit-Reset": components["headers"]["X-RateLimit-Reset"];
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    oauthGoogleCallback: {
        parameters: {
            query?: {
                /** @description Authorization code from Google (present on success) */
                code?: string;
                /** @description State token for CSRF protection (always present) */
                state?: string;
                /**
                 * @description Error code if user denied consent or OAuth failed
                 * @example access_denied
                 */
                error?: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Redirect back to application */
            302: {
                headers: {
                    /**
                     * @description Redirect to the original redirect URL with status query parameter:
                     *     - Success: {redirectUrl}?status=connected
                     *     - Failure: {redirectUrl}?status=error&reason={errorCode}
                     *
                     *     Error reason codes:
                     *     - access_denied: User denied consent
                     *     - state_invalid: State token validation failed (CSRF attack attempt)
                     *     - state_expired: State token expired (>10min since /connect call)
                     *     - state_reused: State token already used (replay attack attempt)
                     *     - email_mismatch: Google account email doesn't match Kinde user (Issue #4)
                     *     - token_exchange_failed: Failed to exchange code for tokens
                     *     - storage_failed: Failed to store tokens
                     * @example https://vnlaw.app/workspace?status=connected
                     */
                    Location?: string;
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Invalid callback parameters (missing state or code) */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    disconnectWorkspace: {
        parameters: {
            query?: never;
            header: {
                /**
                 * @description Client-generated session ID (UUID v4) persisted per browser tab.
                 *     Generated via `crypto.randomUUID()` on first use, stored in sessionStorage.
                 *     Required for all authenticated endpoints. Unique per tab instance.
                 */
                "X-Session-Id": components["parameters"]["XSessionId"];
                /** @description Optional client-generated request ID (UUID v4). If omitted, backend generates its own requestId. */
                "X-Request-Id"?: components["parameters"]["XRequestId"];
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Workspace disconnected successfully */
            200: {
                headers: {
                    "X-RateLimit-Limit": components["headers"]["X-RateLimit-Limit"];
                    "X-RateLimit-Remaining": components["headers"]["X-RateLimit-Remaining"];
                    "X-RateLimit-Reset": components["headers"]["X-RateLimit-Reset"];
                    [name: string]: unknown;
                };
                content: {
                    /**
                     * @example {
                     *       "requestId": "a1b2c3d4-e5f6-7890-abcd-ef1234567890",
                     *       "email": "user@vnlaw.com.vn",
                     *       "name": "User Name",
                     *       "picture": "https://lh3.googleusercontent.com/...",
                     *       "workspace": {
                     *         "connected": false,
                     *         "connectedEmail": null,
                     *         "scopes": [],
                     *         "connectUrl": "https://api.vnlaw.app/v1/oauth/google/connect?redirect=/workspace"
                     *       }
                     *     }
                     */
                    "application/json": components["schemas"]["UserProfile"];
                };
            };
            /** @description Authentication required (invalid/expired Kinde token) */
            401: {
                headers: {
                    "X-RateLimit-Limit": components["headers"]["X-RateLimit-Limit"];
                    "X-RateLimit-Remaining": components["headers"]["X-RateLimit-Remaining"];
                    "X-RateLimit-Reset": components["headers"]["X-RateLimit-Reset"];
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description No workspace connection exists for this user */
            404: {
                headers: {
                    "X-RateLimit-Limit": components["headers"]["X-RateLimit-Limit"];
                    "X-RateLimit-Remaining": components["headers"]["X-RateLimit-Remaining"];
                    "X-RateLimit-Reset": components["headers"]["X-RateLimit-Reset"];
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Rate limited */
            429: {
                headers: {
                    "X-RateLimit-Limit": components["headers"]["X-RateLimit-Limit"];
                    "X-RateLimit-Remaining": components["headers"]["X-RateLimit-Remaining"];
                    "X-RateLimit-Reset": components["headers"]["X-RateLimit-Reset"];
                    "Retry-After": components["headers"]["Retry-After"];
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Server error (failed to revoke tokens) */
            500: {
                headers: {
                    "X-RateLimit-Limit": components["headers"]["X-RateLimit-Limit"];
                    "X-RateLimit-Remaining": components["headers"]["X-RateLimit-Remaining"];
                    "X-RateLimit-Reset": components["headers"]["X-RateLimit-Reset"];
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
}
